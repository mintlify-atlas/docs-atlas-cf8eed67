---
title: Performance Optimization
description: Tips and best practices for optimizing fzf performance with large datasets
---

fzf is fast. Performance should not be a problem in most use cases. However, you might want to be aware of the options that can affect performance.

## Performance Considerations

### ANSI Color Parsing

<Warning>
`--ansi` tells fzf to extract and parse ANSI color codes in the input, and it makes the initial scanning slower. It's not recommended that you add it to your `$FZF_DEFAULT_OPTS`.
</Warning>

Only use `--ansi` when your input contains ANSI color codes that you want to preserve:

```bash
# Good: Use --ansi only when needed
rg --color=always "pattern" | fzf --ansi

# Bad: Don't add it to default options
export FZF_DEFAULT_OPTS="--ansi"  # Don't do this
```

### Field Tokenization

`--nth` makes fzf slower because it has to tokenize each line to extract specific fields:

```bash
# This will be slower due to tokenization
ps -ef | fzf --nth 8..

# Without --nth, fzf searches the entire line (faster)
ps -ef | fzf
```

<Tip>
Only use `--nth` when you need to restrict the search to specific fields.
</Tip>

### Delimiter Performance

<Steps>
  <Step title="Use plain string delimiters">
    A plain string `--delimiter` should be preferred over a regular expression delimiter.
    
    ```bash
    # Faster: Plain string delimiter
    fzf --delimiter ':' --nth 2
    
    # Slower: Regex delimiter
    fzf --delimiter '[:\t]' --nth 2
    ```
  </Step>
  
  <Step title="Avoid complex regex patterns">
    If you must use a regex delimiter, keep it as simple as possible:
    
    ```bash
    # Better
    git grep --line-number . | fzf --delimiter ':' --nth 3..
    
    # Avoid complex patterns when possible
    fzf --delimiter '\s+|[,;]'
    ```
  </Step>
</Steps>

### Line Reassembly

`--with-nth` makes fzf slower as fzf has to tokenize and reassemble each line:

```bash
# This requires tokenization AND reassembly
ps -ef | fzf --delimiter '\s+' --with-nth 1,8..

# Faster: Just use --nth to limit search scope
ps -ef | fzf --delimiter '\s+' --nth 8..
```

<Note>
Use `--with-nth` only when you need to transform the display of items. For search scope limitation, use `--nth` instead.
</Note>

## Optimization Strategies

### Use Ripgrep for Large Text Searches

fzf is designed for filtering lists, not searching text inside files. For that, use Ripgrep:

<CodeGroup>
```bash As primary filter
# Ripgrep does the heavy lifting, fzf adds interactivity
rg --color=always --line-number --no-heading --smart-case "pattern" |
  fzf --ansi
```

```bash Interactive launcher
# Ripgrep restarts on every query change
RG_PREFIX="rg --column --line-number --no-heading --color=always --smart-case "
fzf --ansi --disabled \
    --bind "start:reload:$RG_PREFIX ''" \
    --bind "change:reload:sleep 0.1; $RG_PREFIX {q} || true"
```
</CodeGroup>

The `sleep 0.1` provides debouncing to reduce the number of intermediate Ripgrep processes while typing.

### Limit Preview Logs

When previewing logs, limit the output to prevent excessive memory consumption:

```bash
# Limit initial log amount
kubectl get pods --all-namespaces | fzf \
  --preview 'kubectl logs --follow --all-containers --tail=10000 --namespace {1} {2}'
```

<Warning>
Holding on to a large amount of log data will consume a lot of memory.
</Warning>

### Choose the Right Scheme

fzf provides schemes optimized for different input types:

```bash
# For file paths
fzf --scheme=path

# For command history
fzf --scheme=history

# General purpose (default)
fzf --scheme=default
```

See `fzf --man` for details on how each scheme affects the algorithm.

## Performance Testing

Test performance with large datasets:

```bash
# Generate 1 million lines
seq 1000000 | fzf

# Test with --ansi (will be slower)
seq 1000000 | awk '{print "\033[32m" $0 "\033[0m"}' | fzf --ansi

# Test with tokenization
seq 1000000 | awk '{print $0 ":" $0 ":" $0}' | fzf --delimiter ':' --nth 2
```

<Tip>
Profile your specific use case to identify bottlenecks. What works for one scenario may not work for another.
</Tip>
